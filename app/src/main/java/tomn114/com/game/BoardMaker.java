package tomn114.com.game;

import android.app.Activity;
import android.util.Log;
import android.widget.TextView;

import java.util.ArrayList;

public class BoardMaker {

    public static boolean[][][] allBoards;

    public static final boolean[][] tutorialBoard = { {true, true, true, true, true},
                                                      {true, true, false, false, true},
                                                      {true, true, true, true, false},
                                                      {true, true, true, true, true},
                                                      {true, true, true, true, true}};

    private int[] pathX, pathY, tempXY;
    private ArrayList<int[]> important = new ArrayList<>();

    private final int barrierNum = 15;
    private int counter = 0, runCounter = 0;
    private int barrierCounter;
    private int difficulty = 3;
    private int minMoves;
    private int temp;
    private int boardLength = 5;
    private int boardWidth = 5;
    private int startX, startY;
    private int endX, endY;


    public BoardMaker(){
        allBoards = new boolean[GamePanel.NUM_OF_LEVELS][boardLength][boardWidth];
        GamePanel.minTotal = 0;

        for(int i = 0;i<GamePanel.NUM_OF_LEVELS;i++){
            makeIt();
            GamePanel.storeSX[i]=startX;
            GamePanel.storeSY[i]=startY;
            GamePanel.storeEX[i]=endX;
            GamePanel.storeEY[i]=endY;
            GamePanel.minTotal+=minMoves;
        }
    }

    //Primarily used to setup the tutorial level
    public BoardMaker(int levels){
        allBoards = new boolean[levels][boardLength][boardWidth];
        allBoards[0] = tutorialBoard;

        int startX = 4;
        int startY = 0;
        int endX = 0;
        int endY = 4;

        GamePanel.storeSX[0] = startX;
        GamePanel.storeSY[0] = startY;
        GamePanel.storeEX[0] = endX;
        GamePanel.storeEY[0] = endY;
        minMoves = BoardUtilities.checkBoard(allBoards[0], startX, startY, endX, endY, boardLength, boardWidth);
        GamePanel.minTotal = minMoves;
    }

    //Creates the board by calling makeBoard
    public void makeIt() {
        runCounter++;
        barrierCounter = barrierNum;

        startX = (int) (Math.random() * 2) + boardWidth - 2;
        startY = (int) (Math.random() * 2);

        boolean valid = pathFind();

        if (!valid) {
            important.clear();
            makeIt();
        } else {
            //generate random barriers on non-important squares
            barrierCounter = barrierNum;
            for (int i = 0; i < boardLength; i++) {
                for (int j = 0; j < boardWidth; j++) {
                    temp = (int) (Math.random() * 3);
                    if (temp == 0 && barrierCounter != 0 && !importantBlock(i, j)) {
                        allBoards[counter][i][j] = false;
                        barrierCounter--;
                    } else allBoards[counter][i][j] = true;
                }
            }
            //lowers the difficulty if a level cannot be generated by 8000 levels
            //prevents StackOverflow
            if (runCounter == 8000) {
                runCounter = 0;
                difficulty--;
            }

            allBoards[counter][startX][startY] = true;
            allBoards[counter][endX][endY] = true;
            minMoves = BoardUtilities.checkBoard(allBoards[counter], startX, startY, endX, endY, boardLength, boardWidth);

            /*if the board is not possible to complete it will re-call the method*/
            if (minMoves == boardLength * boardWidth || minMoves < difficulty - 1) {
                important.clear();
                makeIt();
            } else {
                important.clear();
                difficulty++;
                counter++;
            }
        }
    }
    private boolean importantBlock(int x, int y) {
        for(int i=0;i<important.size();i++)
            if(important.get(i)[0]==x && important.get(i)[1]==y) return true;;

        return false;
    }

    private boolean pathFind() {
        tempXY = new int[] {startX, startY};
        important.add(tempXY);

        pathX = new int[difficulty];
        pathY = new int[difficulty];

        pathX[0] = startX;
        pathY[0] = startY;

        for(int i=1;i<difficulty;i++) {
            tempXY = chooseNextStep(pathX[i-1],pathY[i-1]);
            if(tempXY[0]==-1 && tempXY[1]==-1) {
                return false;
            }
            pathX[i] = tempXY[0];
            pathY[i] = tempXY[1];
        }

        endX = pathX[pathX.length-1];
        endY = pathY[pathY.length-1];
        return true;
    }

    //finds next step in the randomized route
    private int[] chooseNextStep(int tx, int ty) {
		/*
		System.out.println("POSITION:");
		System.out.println(tx + " "  + ty);
		*/

        int[] tA = new int[2];
        ArrayList<Integer> possible = new ArrayList<Integer>();

        //Sees available possible moves
        if(tx+1<boardLength && ty+2<boardWidth && !importantBlock(tx+1,ty+2)){
            possible.add(0);
        }
        if(tx+1<boardLength && ty-2>=0 && !importantBlock(tx+1,ty-2)) {
            possible.add(1);
        }
        if(tx+2<boardLength && ty+1<boardWidth && !importantBlock(tx+2,ty+1)) {
            possible.add(2);
        }
        if(tx+2<boardLength && ty-1>=0 && !importantBlock(tx+2,ty-1)) {
            possible.add(3);
        }
        if(tx-1>=0 && ty+2<boardWidth && !importantBlock(tx-1,ty+2)) {
            possible.add(4);
        }
        if(tx-1>=0 && ty-2>=0 && !importantBlock(tx-1,ty-2)) {
            possible.add(5);
        }
        if(tx-2>=0 && ty+1<boardWidth && !importantBlock(tx-2,ty+1)) {
            possible.add(6);
        }
        if(tx-2>=0 && ty-1>=0 && !importantBlock(tx-2,ty-1)) {
            possible.add(7);
        }

		/*
		System.out.println("POSSIBLE:");
		System.out.println(possible);*/

        int t = 0, select = 0;

        if(possible.size()>0) {
            t = (int)(Math.random()*possible.size());
            select = possible.get(t);
        }
        else {
            tA[0] = -1;
            tA[1] = -1;
			/*System.out.println();
			System.out.println("FAILED");
			System.out.println();*/
            return tA;
        }

        if(select==0) {
            tA[0] = tx+1;
            tA[1] = ty+2;
        }
        else if(select==1) {
            tA[0] = tx+1;
            tA[1] = ty-2;
        }
        else if(select==2) {
            tA[0] = tx+2;
            tA[1] = ty+1;
        }
        else if(select==3) {
            tA[0] = tx+2;
            tA[1] = ty-1;
        }
        else if(select==4) {
            tA[0] = tx-1;
            tA[1] = ty+2;
        }
        else if(select==5) {
            tA[0] = tx-1;
            tA[1] = ty-2;
        }
        else if(select==6) {
            tA[0] = tx-2;
            tA[1] = ty+1;
        }
        else if(select==7) {
            tA[0] = tx-2;
            tA[1] = ty-1;
        }

        possible.clear();

		/*System.out.println("IMPORTANT: ");
		for(int i=0;i<important.size();i++) {
			System.out.println(important.get(i)[0] + " " + important.get(i)[1]);
		}
		System.out.println();*/

        int[] temp = new int[2];
        temp[0] = tA[0];
        temp[1] = tA[1];
        important.add(temp);

        return tA;
    }
}
